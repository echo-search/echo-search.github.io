<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>PDF Tool with Popup Crop</title>

<!-- PDF.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>

<!-- pdf-lib -->
<script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>

<style>
  body { font-family: sans-serif; padding: 20px; }
  .pageWrapper {
    position: relative;
    display: inline-block;
    margin: 20px;
  }
  .cropBtn {
    position: absolute;
    top: 6px;
    right: 6px;
    background: #000000aa;
    color: white;
    padding: 6px 8px;
    border-radius: 5px;
    cursor: pointer;
    font-size: 14px;
  }
  /* Popup */
  #cropPopup {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    border: 2px solid #444;
    padding: 20px;
    z-index: 999;
    display: none;
  }
  #popupCanvas {
    border: 1px solid #aaa;
    cursor: crosshair;
    display: block;
    margin-bottom: 10px;
  }
  #popupClose {
    margin-right: 10px;
  }
</style>
</head>

<body>

<h2>PDF Split / Range / Popup Crop Tool</h2>
<input type="file" id="fileInput" accept="application/pdf">

<br><br>

<button id="splitPages">Download Each Page Separately</button>
<br><br>

<label>Range:</label>
<input id="rangeStart" type="number" min="1" placeholder="Start">
<input id="rangeEnd" type="number" min="1" placeholder="End">
<button id="downloadRange">Download Range</button>

<hr>

<div id="pages"></div>

<!-- Popup Crop Window -->
<div id="cropPopup">
  <canvas id="popupCanvas"></canvas>
  <button id="popupClose">Cancel</button>
  <button id="popupCrop">Crop & Download</button>
</div>

<script>
let pdfDoc = null;
let fileBytes = null;
let currentCropPage = null;

let sx, sy, ex, ey;
let isDrawing = false;

// Load PDF
document.getElementById("fileInput").onchange = async (e) => {
  const file = e.target.files[0];
  fileBytes = await file.arrayBuffer();
  pdfDoc = await pdfjsLib.getDocument(fileBytes).promise;

  renderAllPages();
};

// Render all pages with crop icons
async function renderAllPages() {
  const container = document.getElementById("pages");
  container.innerHTML = "";

  for (let i = 1; i <= pdfDoc.numPages; i++) {
    const wrapper = document.createElement("div");
    wrapper.className = "pageWrapper";

    const canvas = document.createElement("canvas");
    canvas.dataset.page = i;

    const crop = document.createElement("div");
    crop.className = "cropBtn";
    crop.innerText = "âœ‚ Crop";
    crop.onclick = () => openCropPopup(i);

    wrapper.appendChild(canvas);
    wrapper.appendChild(crop);
    container.appendChild(wrapper);

    renderPageToCanvas(i, canvas);
  }
}

async function renderPageToCanvas(pageNum, canvas) {
  const page = await pdfDoc.getPage(pageNum);
  const viewport = page.getViewport({ scale: 1.5 });

  canvas.width = viewport.width;
  canvas.height = viewport.height;
  const ctx = canvas.getContext("2d");

  page.render({ canvasContext: ctx, viewport });
}

// Open popup crop tool
async function openCropPopup(pageNum) {
  currentCropPage = pageNum;

  const popup = document.getElementById("cropPopup");
  const popupCanvas = document.getElementById("popupCanvas");
  const ctx = popupCanvas.getContext("2d");

  const page = await pdfDoc.getPage(pageNum);
  const viewport = page.getViewport({ scale: 1.5 });

  popupCanvas.width = viewport.width;
  popupCanvas.height = viewport.height;

  await page.render({ canvasContext: ctx, viewport }).promise;

  popup.style.display = "block";
}

// Draw crop rectangle
const pop = document.getElementById("popupCanvas");
pop.addEventListener("mousedown", e => {
  const r = pop.getBoundingClientRect();
  sx = e.clientX - r.left;
  sy = e.clientY - r.top;
  isDrawing = true;
});

pop.addEventListener("mousemove", e => {
  if (!isDrawing) return;
  const ctx = pop.getContext("2d");

  const r = pop.getBoundingClientRect();
  ex = e.clientX - r.left;
  ey = e.clientY - r.top;

  ctx.clearRect(0, 0, pop.width, pop.height);

  pdfDoc.getPage(currentCropPage).then(page => {
    page.render({
      canvasContext: ctx,
      viewport: page.getViewport({ scale: 1.5 })
    });
  });

  ctx.beginPath();
  ctx.rect(sx, sy, ex - sx, ey - sy);
  ctx.lineWidth = 2;
  ctx.strokeStyle = "red";
  ctx.stroke();
});

pop.addEventListener("mouseup", () => {
  isDrawing = false;
});

// Crop & download
document.getElementById("popupCrop").onclick = async () => {
  const original = await PDFLib.PDFDocument.load(fileBytes);
  const newPDF = await PDFLib.PDFDocument.create();

  const [page] = await newPDF.copyPages(original, [currentCropPage - 1]);

  const left = Math.min(sx, ex);
  const bottom = pop.height - Math.max(sy, ey);
  const width = Math.abs(ex - sx);
  const height = Math.abs(ey - sy);

  page.setCropBox(left, bottom, width, height);
  newPDF.addPage(page);

  const bytes = await newPDF.save();
  download(bytes, `cropped-page-${currentCropPage}.pdf`);

  closePopup();
};

document.getElementById("popupClose").onclick = closePopup;
function closePopup() {
  document.getElementById("cropPopup").style.display = "none";
}

// Save helper
function download(bytes, name) {
  const blob = new Blob([bytes]);
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = name;
  a.click();
  URL.revokeObjectURL(url);
}

/* SPLIT + RANGE */

document.getElementById("splitPages").onclick = async () => {
  const original = await PDFLib.PDFDocument.load(fileBytes);

  for (let i = 0; i < original.getPageCount(); i++) {
    const newPDF = await PDFLib.PDFDocument.create();
    const [p] = await newPDF.copyPages(original, [i]);
    newPDF.addPage(p);

    const bytes = await newPDF.save();
    download(bytes, `page-${i + 1}.pdf`);
  }
};

document.getElementById("downloadRange").onclick = async () => {
  const s = +document.getElementById("rangeStart").value;
  const e = +document.getElementById("rangeEnd").value;

  if (!s || !e || s > e) return alert("Invalid range");

  const original = await PDFLib.PDFDocument.load(fileBytes);
  const newPDF = await PDFLib.PDFDocument.create();

  for (let i = s - 1; i < e; i++) {
    const [p] = await newPDF.copyPages(original, [i]);
    newPDF.addPage(p);
  }

  const bytes = await newPDF.save();
  download(bytes, `range-${s}-${e}.pdf`);
};
</script>

</body>
</html>
