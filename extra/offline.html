<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Trench Run — Offline</title>
<style>
  :root{--bg:#070710;--ui:#e6e6e6;--accent:#ffdd57}
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:var(--bg);color:var(--ui)}
  #wrap{display:flex;flex-direction:column;align-items:center;gap:12px;padding:18px}
  header{width:100%;max-width:980px;display:flex;justify-content:space-between;align-items:center}
  h1{font-size:18px;margin:0}
  .msg{background:#1a1a27;border:1px solid rgba(255,255,255,0.03);padding:10px;border-radius:8px}
  #container{width:100%;max-width:980px;display:flex;gap:12px;align-items:start}
  canvas{background:transparent;border-radius:8px;background-image:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0)); box-shadow:0 8px 30px rgba(0,0,0,0.6)}
  #panel{width:260px;min-height:480px;background:#0e0e16;padding:14px;border-radius:8px;box-shadow:inset 0 1px 0 rgba(255,255,255,0.02)}
  button{display:inline-block;padding:8px 12px;border-radius:8px;border:0;background:var(--accent);color:#111;font-weight:700;cursor:pointer}
  .small{font-size:13px;color:#cfcfcf}
  .offline-banner{display:flex;flex-direction:column;gap:8px;padding:12px;border-radius:8px;background:#2d0f0f;color:#ffdede}
  .controls{margin-top:10px;font-size:13px;color:#dcdcdc}
  .center{display:flex;align-items:center;justify-content:center}
  footer{font-size:12px;color:#9a9a9a;margin-top:10px}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <h1>Trench Run — Offline</h1>
    <div class="small">Controls: ← → or A D • Space to shoot • P to pause</div>
  </header>

  <div id="container">
    <canvas id="game" width="720" height="480"></canvas>

    <div id="panel" class="msg">
      <div id="offlineBox" class="offline-banner" style="display:none">
        <strong>Oops... you're offline.</strong>
        <div>In the meantime, you can play Trench Run — offline and fast.</div>
      </div>

      <div style="margin-top:10px">
        <div><strong>Score</strong></div>
        <div id="score" style="font-size:28px;margin-top:8px">0</div>
      </div>

      <div style="margin-top:14px">
        <div class="small">Lives</div>
        <div id="lives" style="font-size:22px;margin-top:6px">3</div>
      </div>

      <div style="margin-top:14px">
        <div class="small">High score (local)</div>
        <div id="hi" style="font-size:18px;margin-top:6px">0</div>
      </div>

      <div style="margin-top:18px" class="controls">
        <div><strong>How to play</strong></div>
        <ol style="padding-left:18px;margin:6px 0 0 0">
          <li>Steer left/right to avoid blocks</li>
          <li>Shoot obstacles to clear them</li>
          <li>Survive as long as you can — score grows with distance</li>
        </ol>
      </div>

      <div style="margin-top:14px" class="center">
        <button id="startBtn">Start / Restart</button>
      </div>

      <div style="margin-top:12px" class="small">This is an original offline clone — not the Math Playground file.</div>
    </div>
  </div>

  <footer class="small">Save page to disk to keep it offline. Works in Chrome/Edge/Firefox. Mobile controls: tap left/right halves to steer.</footer>
</div>

<script>
/* ---------- Basic offline banner ---------- */
function updateOnlineStatus(){
  const box = document.getElementById('offlineBox');
  if(!navigator.onLine) { box.style.display = 'flex' }
  else { box.style.display = 'none' }
}
window.addEventListener('online', updateOnlineStatus);
window.addEventListener('offline', updateOnlineStatus);
updateOnlineStatus();

/* ---------- Game core ---------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', {alpha:true});
const W = canvas.width, H = canvas.height;

let keys = {};
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; if(e.key===' '){ e.preventDefault(); }});
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

canvas.addEventListener('pointerdown', e => {
  // mobile: left half move left, right half move right while pointer pressed
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  if(x < rect.width/2) keys.pointerLeft = true; else keys.pointerRight = true;
});
canvas.addEventListener('pointerup', e => { keys.pointerLeft = false; keys.pointerRight = false; });

const state = {
  running:false, paused:false, score:0, lives:3, hi: localStorage.getItem('trench_hi')||0
};

document.getElementById('hi').textContent = state.hi;

/* Player */
const player = {
  x: W/2, y: H - 80, w: 28, h: 40, speed: 6,
  bullets: []
};

/* Obstacles and trench lines */
let obstacles = [];
let lines = [];
let tick = 0;

/* Helpers */
function rand(a,b){ return a + Math.random()*(b-a) }
function rectsIntersect(a,b){
  return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.h + a.y > b.y;
}

/* Reset */
function reset(){
  obstacles = [];
  lines = [];
  tick=0;
  state.score = 0;
  state.lives = 3;
  player.x = W/2;
  player.bullets = [];
  state.running = true;
  state.paused = false;
  document.getElementById('score').textContent = 0;
  document.getElementById('lives').textContent = state.lives;
}

/* Start button */
document.getElementById('startBtn').addEventListener('click', ()=> reset());

/* Game loop */
function spawnObstacle(){
  // spawn across the trench width, with perspective scaling (appears smaller when far)
  const lane = rand(0.15,0.85)*W;
  const size = rand(28,64);
  // spawn at negative y (far)
  obstacles.push({x: lane - size/2, y: -80, w: size, h: size, speed: rand(2.4,4.4), hp: 1});
}

function update(dt){
  if(!state.running || state.paused) return;

  tick += dt;
  // controls
  const left = keys['arrowleft'] || keys['a'] || keys.pointerLeft;
  const right = keys['arrowright'] || keys['d'] || keys.pointerRight;
  if(left) player.x -= player.speed;
  if(right) player.x += player.speed;
  player.x = Math.max(30, Math.min(W-30-player.w, player.x));

  // shooting
  if(keys[' '] && tick%10 < 2){ // simple rate limit
    player.bullets.push({x: player.x + player.w/2 - 3, y: player.y - 10, w:6, h:10, speed:8});
  }

  // bullets move
  for(let b of player.bullets) b.y -= b.speed;
  player.bullets = player.bullets.filter(b => b.y + b.h > -20);

  // spawn obstacles occasionally
  if(Math.random() < 0.02 + Math.min(0.1, state.score/3000)) spawnObstacle();

  // obstacles move forward (down the screen)
  for(let ob of obstacles){
    ob.y += ob.speed + Math.min(4, state.score/1000);
    // slight horizontal drift for some variation
    ob.x += Math.sin((tick+ob.y)/200)*0.4;
  }

  // collision bullets vs obstacles
  for(let i = obstacles.length-1; i>=0; i--){
    const ob = obstacles[i];
    for(let j = player.bullets.length-1; j>=0; j--){
      const b = player.bullets[j];
      if(rectsIntersect(ob, b)){
        ob.hp--;
        player.bullets.splice(j,1);
        if(ob.hp<=0){
          obstacles.splice(i,1);
          state.score += Math.floor(50 + ob.w);
          break;
        }
      }
    }
  }

  // collision player vs obstacles
  for(let i = obstacles.length-1; i>=0; i--){
    const ob = obstacles[i];
    const px = {x:player.x, y:player.y, w:player.w, h:player.h};
    if(rectsIntersect(px, ob)){
      obstacles.splice(i,1);
      state.lives--;
      document.getElementById('lives').textContent = state.lives;
      if(state.lives <= 0){
        state.running = false;
        // high score
        if(state.score > state.hi){
          state.hi = state.score;
          localStorage.setItem('trench_hi', state.hi);
          document.getElementById('hi').textContent = state.hi;
        }
      }
    }
  }

  // remove obstacles off-screen and increase score (distance)
  for(let i = obstacles.length-1; i>=0; i--){
    if(obstacles[i].y > H+100) {
      obstacles.splice(i,1);
      state.score += 10;
    }
  }

  // increment score with time
  state.score += Math.floor(dt*8);
  document.getElementById('score').textContent = state.score;
}

/* Render */
function drawTrench(){
  // draw perspective walls — simple center vanishing point
  const cx = W/2;
  const vpY = H*0.25;
  ctx.save();
  // floor lines
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(255,255,255,0.03)';
  for(let i=0;i<24;i++){
    const t = (i + (tick/60)) % 24;
    const y = vpY + (t/24)*(H - vpY);
    const gap = 60 * (1 - (y - vpY) / (H - vpY));
    ctx.beginPath();
    ctx.moveTo(cx - 220*(1 - (y - vpY)/(H-vpY)), y);
    ctx.lineTo(cx + 220*(1 - (y - vpY)/(H-vpY)), y);
    ctx.stroke();
  }

  // side walls (angled)
  ctx.strokeStyle = 'rgba(255,255,255,0.045)';
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(0, H);
  ctx.lineTo(cx - 260, vpY);
  ctx.lineTo(0, vpY+10);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(W, H);
  ctx.lineTo(cx + 260, vpY);
  ctx.lineTo(W, vpY+10);
  ctx.stroke();
  ctx.restore();
}

function draw(){
  // clear
  ctx.clearRect(0,0,W,H);

  // background subtle gradient
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#071023');
  g.addColorStop(1,'#04050a');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  drawTrench();

  // draw obstacles (give them a glowing edge)
  for(let ob of obstacles){
    const depth = 1 - Math.max(0, Math.min(1, (ob.y + 80)/ (H + 200)));
    ctx.save();
    const scale = 0.6 + depth*0.9;
    ctx.translate(ob.x + ob.w/2, ob.y + ob.h/2);
    ctx.scale(scale, scale);
    ctx.fillStyle = 'rgba(200,80,60,0.95)';
    ctx.fillRect(-ob.w/2, -ob.h/2, ob.w, ob.h);
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.lineWidth = 2;
    ctx.strokeRect(-ob.w/2, -ob.h/2, ob.w, ob.h);
    ctx.restore();
  }

  // draw bullets
  ctx.fillStyle = '#fff';
  for(let b of player.bullets){
    ctx.fillRect(b.x, b.y, b.w, b.h);
  }

  // draw player — stylized triangle ship
  ctx.save();
  ctx.translate(player.x + player.w/2, player.y + player.h/2);
  ctx.beginPath();
  ctx.moveTo(0, -player.h/2);
  ctx.lineTo(-player.w/2, player.h/2);
  ctx.lineTo(player.w/2, player.h/2);
  ctx.closePath();
  ctx.fillStyle = '#9be7ff';
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(0,0,0,0.4)';
  ctx.stroke();
  // thruster glow
  ctx.beginPath();
  ctx.moveTo(-8, player.h/2);
  ctx.lineTo(0, player.h/2+10);
  ctx.lineTo(8, player.h/2);
  ctx.closePath();
  ctx.fillStyle = 'rgba(255,180,60,0.9)';
  ctx.fill();
  ctx.restore();

  // HUD text (center top)
  ctx.font = '12px system-ui,Arial';
  ctx.fillStyle = 'rgba(255,255,255,0.06)';
  ctx.fillText('Trench running...', 12, 18);

  // game over overlay
  if(!state.running){
    ctx.fillStyle = 'rgba(4,4,6,0.7)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#fff';
    ctx.font = '28px system-ui, Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Mission Failed', W/2, H/2 - 20);
    ctx.font = '16px system-ui, Arial';
    ctx.fillText('Press Start / Restart to try again', W/2, H/2 + 10);
    ctx.textAlign = 'start';
  }
}

/* Main animation loop */
let last = performance.now();
function loop(now){
  const dt = Math.min(40, now - last);
  last = now;
  if(!state.paused) update(dt/16.6);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* Pause toggle */
window.addEventListener('keydown', e => {
  if(e.key.toLowerCase() === 'p'){
    state.paused = !state.paused;
  }
});

/* Simple touch buttons for mobile (optional) */
(function addTouchHints(){
  const left = document.createElement('div');
  left.style.position='fixed'; left.style.left='6px'; left.style.bottom='6px';
  left.style.width='48px'; left.style.height='48px'; left.style.borderRadius='8px';
  left.style.background='rgba(255,255,255,0.02)'; left.style.zIndex=99; document.body.appendChild(left);
  const right = left.cloneNode(); right.style.left='60px'; document.body.appendChild(right);
  left.addEventListener('pointerdown', ()=> keys.pointerLeft = true);
  left.addEventListener('pointerup', ()=> keys.pointerLeft = false);
  right.addEventListener('pointerdown', ()=> keys.pointerRight = true);
  right.addEventListener('pointerup', ()=> keys.pointerRight = false);
  // keep them invisible on desktop
  if(window.innerWidth > 900){ left.style.display='none'; right.style.display='none'; }
})();

/* Seed some obstacles to make it lively before start */
for(let i=0;i<6;i++) spawnObstacle();
</script>
</body>
      </html>
